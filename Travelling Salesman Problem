from itertools import combinations
import math

# Distance between cities (represented as a matrix)
def tsp_dynamic_programming(distance):
    n = len(distance)
    # memo[(subset_mask, last)] = minimum cost to reach last via subset_mask
    memo = {}

    # Initial state: starting at city 0
    for k in range(1, n):
        memo[(1 << k, k)] = distance[0][k]

    # Build up solutions for subsets of increasing size
    for subset_size in range(2, n):
        for subset in combinations(range(1, n), subset_size):
            bits = 0
            for bit in subset:
                bits |= 1 << bit
            for k in subset:
                prev_bits = bits & ~(1 << k)
                min_dist = math.inf
                for m in subset:
                    if m == k:
                        continue
                    min_dist = min(min_dist, memo[(prev_bits, m)] + distance[m][k])
                memo[(bits, k)] = min_dist

    # Close the tour by returning to city 0
    full_mask = (1 << n) - 2
    min_tour_cost = min(memo[(full_mask, k)] + distance[k][0] for k in range(1, n))

    return min_tour_cost

# Example distance matrix (symmetric)
distance_matrix = [
    [0, 10, 15, 20],
    [10, 0, 35, 25],
    [15, 35, 0, 30],
    [20, 25, 30, 0]
]

min_cost = tsp_dynamic_programming(distance_matrix)
print("Minimum tour cost:",Â min_cost)
